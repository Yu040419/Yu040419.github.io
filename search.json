[{"title":"常見的網站攻擊方式","date":"2021-03-11T07:51:12.000Z","url":"/blog/article/attack/","tags":[["資訊安全","/blog/tags/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/"],["XSS","/blog/tags/XSS/"],["SQL injection","/blog/tags/SQL-injection/"],["CSRF","/blog/tags/CSRF/"]],"categories":[[" ",""]],"content":"在討論常見的網站攻擊方式之前，可以先認識一下 OWASP。 Open Web Application Security Project OWASP 是一個線上社群，介紹了各種不同的網路安全問題、每幾年的十大安全問題排名跟範例，完全免費，基本上是所有做資訊安全的聖經。 推薦 techbridge 的 這篇文章，講了 2010 及 2013 的前十大網站攻擊排行，以及 這篇 是官方在 2017 年十大攻擊手法的中文版本。 XSS Cross-Site-Scripting，俗稱 JavaScript Injection，中文被翻成跨站式腳本攻擊或是跨站攻擊。 XSS 是在使用者可操控的地方，像是留言內容、帳號名稱等地方，惡意寫入程式碼，讓網站載入這些內容時，一起執行這些程式。 常見的可能就是透過插入一個圖片，圖片會自動訪問 hackerhome 上的 grabber.jsp，並將使用者的 cookie 作為 msg 的值，讓受害者的 cookie 遭盜用。 所以要做的事情，就是防範讓伺服器知道這並不是程式碼，而只是一般的文字。可以透過 php 內建的 htmlspecialchars 達成這件事。 但要特別注意的是，並不是像 hash 一樣，在輸入密碼後就馬上處理並將 hash 過的內容存在資料庫，而是儲存原本的字元在資料庫，輸出時再經由htmlspecialchars 轉化。因為輸入防不勝防，直接解決輸出才能打到痛點。 儲存型 stored XSS，或被稱為 persisted XSS 以輸入惡意、並會儲存到資料庫的資料方式攻擊，這種稱為儲存型 XSS，也就是前面提到的攻擊方式。 一般多以這種攻擊方式，因為這種攻擊方式的網址正常，只要成功攻擊，一般使用者只要點入就很有可能被竊取資料、或是被轉到其他網站。 反射型 Reflected XSS 反射型是利用有些網站會將 query string 的內容，直接顯示在螢幕上作為提示文字，竄改 query string 的內容，將惡意程式碼放入 query string 達到攻擊目的。 但這種方式需要刻意讓使用者點選帶有奇怪程式碼的網址，所以一般比較少見。 DOM XSS DOM-Based XSS（基於 DOM 的 XSS 類型） 透過程式碼當中 DOM 節點的 .html 或是 .innerHtml 漏洞，即可輸入 HTML 標籤，也就是可輸入 &lt;script&gt; &lt;img&gt; 標籤，將惡意程式碼帶入。 跟前面兩種 XSS 攻擊手法比較不一樣，前面兩種主要防範方式都是從後端，但 DOM XSS 從前端就可以簡單防範，直接看範例： 如果沒有檢查輸入，輸入可填入以下內容即可輕鬆執行程式碼。 解決方法其實很簡單，只要把 .html 或是 .innerHtml 都改成 .text 及 innerText 就可以了。 SQL Injection 被譯為 SQL 注入或是 SQL 隱碼 SQL Injection 一直是 OWASP 的常勝軍。使用的原理也相似，都是透過原本應該輸入文字或帳密等欄位，輸入了程式碼進去。 跟 XSS 不一樣的是，SQL Injection 是輸入 SQL 的語法，而 XSS 多半是輸入 JS 及 HTML 的語法。 一個有會員登入功能的網站，都會需要輸入帳號與密碼來進行驗證。而後端程式，如 PHP 就必需支援相關的登入檢查，判定 User 輸入的帳號、密碼是否正確，來確定登入是否成功。 但若是駭客輸入有特殊字元的帳號：「 ‘ or 1=1 /* 」，密碼：「任意值」，這時 SQL 語法就會變成： 這時候可以透過 MySQL 內建的語法 Prepared Statements 來解決這個問題。 幾件事情要注意： 只要有 SQL 語法都要改成 prepared statements。 透過 bind_param() 拼接時記得第一個參數，如果要拼接三個字串是 &#39;sss&#39;; 第一個是字串第二個是整數第三個是字串是 &#39;sis&#39;。 CSRF Cross Site Request Forgery，跨站請求偽造 假設我們今天登入 A 網站後沒有自行登出，A 網站會透過 Cookie 記住身分，讓我們下次進入網站的時候不需要再登入一次。但駭客其實可以透過這點，讓你誤點選設計好的 B 網站，透過在進入 B 網站時自動發送假的 request 到 A 網站，A 網站的 Server 端會以為這是我們本人發送的，就可以成功執行 request。 舉例來說，假設我們今天登入了 mybank.com 網站後沒有登出，只要有心人士惡意讓我們點了 myvideo.com 網站： 如果網站沒有做其他驗證的話，其實很有可能就可以直接轉帳出去了。 Double Submit Cookie駭客跟使用者是使用不同的網域，也就是說駭客沒有辦法設定該網域的 Cookie，所以其實可以透過這一點來防範這件事。 由 client side 來生 CSRF token，並且把這個 CSRF token 放進表單及 Cookie 中，在收到 request 的時候 server 再去比對是否有值且相同。 但這還是有可能會遭到破解，如果駭客進入到了子網域中，根據 Cookie 設定規範，子網域能夠存取父網域的 Cookie，還是有可能可以成功被破解。 Samesite瀏覽器本身就有提供防範 CSRF 的機制，而且很簡單。只要在設定 Cookie 的時候多加一個 SameSite 就好了，用意是讓 Cookie 只允許 same site 使用，不應該在任何的跨網域的 request 被加上去。 透過瀏覽器設定的方式是目前最推薦的做法，Lax 與 strict 的差別，及更詳細資訊可參考 這篇文章，這邊的筆記也都是參考此篇文章的。 有趣的測試小遊戲這幾個遊戲都是讓你練習該如何學習駭客透過 XSS 及其他方式執行程式碼。  (解題影片)  (可能會被 chrome 擋下來，可以試著用其他瀏覽器玩)  資料來源 【網頁安全】給網頁開發新人的 XSS 攻擊介紹與防範 SQL Injection 常見的駭客攻擊方式 補充資料 前端安全系列（一）：如何防止 XSS 攻击？ 一次看懂 SQL Injection 的攻擊原理 "},{"title":"密碼保護","date":"2021-03-11T07:40:23.000Z","url":"/blog/article/password/","tags":[["資訊安全","/blog/tags/%E8%B3%87%E8%A8%8A%E5%AE%89%E5%85%A8/"],["加密","/blog/tags/%E5%8A%A0%E5%AF%86/"],["雜湊","/blog/tags/%E9%9B%9C%E6%B9%8A/"],["編碼","/blog/tags/%E7%B7%A8%E7%A2%BC/"]],"categories":[[" ",""]],"content":"當我們把帳號密碼都存在資料庫當中，有個最大的隱憂就是，一旦資料庫遭駭，駭客就可以拿到所有的帳號密碼，造成資訊安全上的危害。 以下簡單簡介常見的幾種密碼保護方式： 編碼 編碼，encode；解碼，decode 編碼並不會修改資料、也沒有任何加密的效果，單純就是換個方式來表達資料而已。最常見的就是摩斯密碼。 對資訊安全，一點幫助都沒有。 加密 加密，encryption 資料加密之前叫做「明文 plaintext」，加密之後叫做「密文 ciphertext」。「加密」是明文變密文，「解密」是密文變明文。 加密有幾個特性： 加密是一對一的關係，也就是說密文在固定加密演算法下，只會對應到一個明文。因而衍伸加密的重要特性，可以解密。 需要密鑰 (key) 才可以進行加密及解密。 分為對稱加密及不對稱加密。 對稱加密只會有一把密鑰。常見的對稱加密法是 AES。 不對稱加密會有兩把密鑰，一把公鑰 ( public key ) 一把私鑰 ( private key )，公鑰負責加密，私鑰負責解密。常見的不對稱加密法是 RSA。 雜湊 雜湊，Hash function，又稱雜湊函式或是雜湊演算法 雜湊有幾個特性： 是單向函式 / 演算法，不能從輸出還原出原本的輸入。 同樣的輸入經過雜湊後，一定會得到同樣的輸出。 不同長度的輸入，會得到固定長度的輸出。 類似鴿籠原理，因為是固定長度的輸出，所以不同輸入可能會產生同個輸出。這樣的情況稱為碰撞 Collision。但一般知名的雜湊發生碰撞的機率很低。 通常會加鹽 (salting)。加鹽通常會自動幫使用者產生一段亂碼，可以穿插放在雜湊前中後，有資安概念的可能會每個人都加上一樣的鹽，厲害點的可以每個人的鹽都不同。一般鹽會由亂數產生，然後把鹽也存在資料庫中，這樣就能有更高的防範， 常見的雜湊演算法: MD5 （ 已被證實不安全 ） SHA-1 （ 已被證實不安全 ） SHA-256 （ 比 MD5 還強、安全性更高的雜湊函數，但對於伺服器來說，越安全、也代表速度越慢 ） 但雜湊也不是說不能解，其實就有一張彩虹表（rainbow table），用原本已經做好字串與雜湊值對照的表格，去強硬破解資料庫裡的密碼。所以由此就可以知道加鹽的重要性。 加密及雜湊兩個在資訊領域中，都是對資料的處理方法，兩者最大的差別就在於 加密可以進行解密（可逆），但雜湊不行還原（不可逆）。 除此之外， hash 也常用在檢查檔案的完整性，許多軟體會提供 hash 過後的文字（校驗碼），讓使用者下載過後可以自行驗證檔案是否有被更改或加料過。 資料來源 [BE101] 用 PHP 與 MySQL 學習後端基礎 一次搞懂密碼學中的三兄弟 — Encode、Encrypt 跟 Hash [第十一週] 資訊安全 - 為什麼密碼要經過雜湊 ？ 推薦閱讀 How Dropbox securely stores your passwords "},{"title":"JavaScript 資料型別","date":"2021-03-09T15:29:02.000Z","url":"/blog/article/%E8%B3%87%E6%96%99%E5%9E%8B%E5%88%A5/","tags":[["JavaScript","/blog/tags/JavaScript/"]],"categories":[[" ",""]],"content":"JavaScript 資料型別有七種，又分為原始型別及物件型別。 原始型別有六種： Boolean 布林，例如：true、false Null 空值 Undefined 未定義 Number 數字，例如：12345 String 字串，例如：&#39;Hello World&#39; Symbol（ES2015 新增） 符號 其他的都是物件型別： Object 物件，包含（物件 Object、陣列 Array、函式 Function、時間 Date…） 辨別方式可以透過 typeof 來辨別型別 註：typeof null 是一個在 JavaScript 剛推出時就存在的 bug，因為擔心改動後會導致太多網站壞掉，所以目前及未來都沒有改的計畫。 仔細看會發現，確實像是時間、陣列都會被辨別為物件，雖然畢竟當初分類就是這麼分的，但在實務使用上還是有點不方便，因此其實有其他方式可以更準確地達到實務上的需求 ─ Object.prototype.toString.call(...) 。 原始型別 VS 物件型別可否更改原值原始型別只能重新賦值，不能更改原值，比方說 物件型別可以更改原值，比方說 變數存放方式之所以會有這樣的差別，最大的差別就在於變數存放的方式。可以想像成變數名稱都是一張 memo 紙，而變數是一個箱子。 在原始型別當中，寫著變數名稱的 memo 紙貼著的箱子裡，放的就是變數的值，但在物件型別當中，寫著變數名稱的 memo 紙貼著的箱子裡，放的是一個記憶體位置，記憶體位置中放的才是變數的值。 綜合以上，我們會稱 ==物件型別是可變的 mutable，原始型別是不可變的 immutable==。 = 與 == 與 === =：賦值 ==：兩邊進行比較，且會自動進行型別轉換 ===：兩邊進行比較，但不進行型別轉換 因此在比較時，永遠都是用 === 最可靠。關於更多的 == 與 === 比較可參考這個 好懂表格。 另外，NaN 不大於、小於、等於任何數字或是 NaN，NaN 與任何數字運算也都會變成 NaN 。"},{"title":"變數宣告，var、let、const 的差別","date":"2021-03-09T15:25:14.000Z","url":"/blog/article/%E8%AE%8A%E6%95%B8%E5%AE%A3%E5%91%8A%EF%BC%8Cvar%E3%80%81let%E3%80%81const-%E7%9A%84%E5%B7%AE%E5%88%A5/","tags":[["JavaScript","/blog/tags/JavaScript/"]],"categories":[[" ",""]],"content":"變數宣告方式有三種，分別是 var、以及 ES6 新增的 let 及 const。 var 跟 let const 最大的差別在於作用域，也就是變數的生存範圍。 在 ES6 之前 var 是以函式 function 為一個作用域，因此稱為 functional scope。而 ES6 之後是以 block 為一個作用域（大括號，像是任何迴圈、條件式等），稱之為 block scope。比方說： var如同前面所說，var 是 function scope，但如果 var 不在 function 裡宣告時，會變成全域變數（global variable），也就是整個檔案都存取的到，沒有作用域之分。 像案例 C 這樣從 test scope 找 a 變數，找不到往外找找到 global scope 的方式，被稱為 scope chain（範圍鍊）。 向案例 F 這樣不使用 function，而是使用條件式時，還記得之前說過 var 除了使用 function 時才有作用域的區別，因為這樣改到 global 原先值的情況，被稱為 ==變數汙染==。 但要特別注意以下情況： 以上很容易會以為印出來的值是 &#39;inner&#39;，不過其實跟函式在哪裡呼叫沒有關係，在設計該 function 時就已經決定好了該變數的 scope chain。不過如果改成以下，把最終的 function 放入： 在上面的例子當中，如果 inner scope 跟 change scope 都沒有宣告 a，那麼找尋的歷程就會是： let &amp; constconst 代表的其實是 constant（常數），也就是不會變的數值。因此let 跟 const 最大的差別就在於 let 宣告的變數可以再重新賦值或更改，但 const 不行。 以上用 let 都沒有這些問題，不過要特別注意： "},{"title":"什麼是 prototype ?","date":"2021-03-09T12:52:49.000Z","url":"/blog/article/prototype/","tags":[["JavaScript","/blog/tags/JavaScript/"]],"categories":[[" ",""]],"content":"前言在 ES5 的 JS 物件導向中，function 被當成建構子以及 class 用，因此被稱為構造函數。構造函數可透過語法 new 建造一個 instance 實體，也可以透過 prototype 做出共用的 method 方法： 不過 JS 是如何知道 calculateA.input 等同於 calculateB.input 的呢？或者可以換個問題，JS 是如何繼承 method 跟 property 的呢？ 透過 __proto__ __proto__當我們建造 instance 時，JS 會自動幫我們在 instance 加上 __proto__ 這個屬性，讓 instance 要使用該 method 找不到時，可以循著 __proto__ 連結，往上找到有這個 method 的 prototype，以上面的例子來說，有點類似這個概念： 像這樣不停往上找，從 這個透過 __proto__ 尋找的過程，被稱為 prototype chain 原型鍊 。 驗證以下介紹三種方式驗證原型鍊： 一、透過 === 值得注意的是，不只有建構式的 prototype 才有 __proto__，建構式本身也有 __proto__。 以上面的例子來說，Calculator 這個建構式的 __proto__會連接到 Function.prototype。 Function.prototype 的 __proto__ 則連接到頂層的 Object.prototype。 仔細想想其實一切都很合理，Calculator 本來就是 Function，連接到 Function 很正常；而 Function 本來就是 Object，連接到 Object 也很正常。可以想像成以下這樣 二、 透過 hasOwnProperty 三、 透過 instanceOf如果 A instanceOf B A 是 B 的實體的話，會回傳 true。 constructor其實每個的 prototype 底下，除了共用的 method、property 以及 __proto__ 外，還有一個叫做 constructor 的屬性。 在前面我們透過 instanceOf 驗證原形鍊時，得知不只是 new 創建出來的 instance 才是 instance，像是 constructor 也是 Object 的 instance。 所以相反的，Object.prototype 底下的 constructor 屬性也是 Object，因為他們自己就是建構式，可以 new 出 constructor。當然 Calculator.prototype.constructor = Calculator ，因為 Calculator 本身就是 constructor 拉，他的 constructor 也自然指向自己。 因此任何 X.prototype.constructor = X 。 new了解原型鍊後就容易理解 new 是如何運作的，其實他幫我們做的步驟如下： 創建一個空物件（以下簡稱 O），將 O 當成是 new 出來的實體 透過 __proto__ 讓 O 跟建構函式產生連結 將 O 當成建構函式裡的 this 並透過 call 或 apply 執行建構函式 回傳 O "},{"title":"關於我","date":"2021-03-13T15:08:15.072Z","url":"/blog/about/index.html","categories":[[" ",""]],"content":"關於我我是 Yu，在台灣的網頁前端工程師。 喜歡旅行、爬山、看書和追劇，關注環境保護及人權，在這主要分享個人學習筆記，內容如有任何錯誤歡迎指正。 "},{"title":"搜尋本站","date":"2021-03-13T15:02:34.000Z","url":"/blog/search/index.html","categories":[[" ",""]]},{"title":"archives","date":"2021-03-13T11:49:15.000Z","url":"/blog/archives/index.html","categories":[[" ",""]]},{"title":"標籤","date":"2021-03-13T15:10:26.000Z","url":"/blog/tags/index.html","categories":[[" ",""]]}]